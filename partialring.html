<!doctype html>
<html>
<meta charset="UTF-8">
<head>
<title>Partial Ring - Indicate directions with a decimated ring of points</title>
</head>
<body>
<table>
<tr><td><canvas id="canvas5" tabindex='1' width="100" height="100"></canvas></td>
    <td><span style="BORDER-LEFT: black 0.025in solid; DISPLAY: inline-block; HEIGHT: 1.1in"></span></td>
    <td><canvas id="canvas6" tabindex='1' width="100" height="100"></canvas></td>
    <td></td><td></td><td></td>
    </tr>
<tr><td><hr></td><td></td><td><hr></td></tr>
<tr><td><canvas id="canvas7" tabindex='1' width="100" height="100"></canvas></td>
    <td><span style="BORDER-LEFT: black 0.025in solid; DISPLAY: inline-block; HEIGHT: 1.1in"></span></td>
    <td><canvas id="canvas8" tabindex='1' width="100" height="100"></canvas></td>
    <td></td><td></td><td></td>
    </tr>
<tr>
    <td></td><td></td><td></td>
    <td><canvas id="canvas9" tabindex='1' width="100" height="100"></canvas></td>
    <td><span style="BORDER-LEFT: black 0.025in solid; DISPLAY: inline-block; HEIGHT: 1.1in"></span></td>
    <td><canvas id="canvasA" tabindex='1' width="100" height="100"></canvas></td>
    </tr>
<tr>
    <td></td><td></td><td></td>
    <td><hr></td><td></td><td><hr></td></tr>
<tr>
    <td></td><td></td><td></td>
    <td><canvas id="canvasB" tabindex='1' width="100" height="100"></canvas></td>
    <td><span style="BORDER-LEFT: black 0.025in solid; DISPLAY: inline-block; HEIGHT: 1.1in"></span></td>
    <td><canvas id="canvasC" tabindex='1' width="100" height="100"></canvas></td>
    </tr>
</table>
<p>
In each of the figures, the black line segments have no other line segments that are parallel.
Each of the filled-in black points is the endpoint of at least one black line.
<p>
The gray lines connect two filled-in black points but the gray lines have another gray line
in the figure which is parallel.  See if you can pick out the trapezoid(s) with the
parallel gray lines.  This is pretty easy to spot in the first figure.
<script>
	// Partial Ring
	function PartialRing(total,id){
		this.init = function(total){
			if(total < 4){
				total = 4;
			}
			for(var i=0;i<total;i++){
				this.point.push({
					x: Math.cos(Math.PI*2*i/total),
					y: Math.sin(Math.PI*2*i/total),
					angle: 360*i/total,
					enable: true
				});
			}
		}
		this.isDuplicate = function(i,j,lmod){
			var jb=(j+lmod-i)%lmod;

			// One way
			if(jb >=3){
				for(var k=1;(2*k)<jb;k++){
					if(this.point[(i+k+lmod)%lmod].enable && this.point[(j-k+lmod)%lmod].enable){
						return true;
					}
				}
			}

			// The other way
			if(jb < (lmod-2)){
				for(var k=1;((2*k)+jb)<lmod;k++){
					if(this.point[(i-k+lmod)%lmod].enable && this.point[(j+k+lmod)%lmod].enable){
						return true;
					}
				}
			}
			return false;
		}
		this.decimate = function(){
			// abbreviation, used a lot here
			const lmod=this.point.length;
			// Check every point to see if it is redundant 
			for(var i=0;i<lmod;i++){
				var required=false;
				for(var jb=1;jb<lmod;jb++){
					var j=(i+jb)%lmod;
//					var duplicate=false;
//					// One way
//					if(jb >=3){
//						for(var k=1;(2*k)<jb;k++){
//							if(this.point[(i+k+lmod)%lmod].enable && this.point[(j-k+lmod)%lmod].enable){
//								duplicate=true;
//								break;
//							}
//						}
//					}

					// The other way
//					if(jb < (lmod-2)){
//						for(var k=1;((2*k)+jb)<lmod;k++){
//							if(this.point[(i-k+lmod)%lmod].enable && this.point[(j+k+lmod)%lmod].enable){
//								duplicate=true;
//								break;
//							}
//						}
//					}
//					if(duplicate === false){
					if(this.isDuplicate(i,j,lmod) === false){
						required=true;
						break;
					}
				}
				if(required === false){
					this.point[i].enable=false;
				}
			}
		}
		this.draw = function(ctx){
			var xc=Math.floor(ctx.canvas.width/2);
			var yc=Math.floor(ctx.canvas.height/2);
			var lr=3;
			var radius=Math.min(xc,yc)-lr;

			ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
			ctx.fillStyle = "#000000";
			ctx.strokeStyle = "#000000";

			for(var i=0;i<this.point.length;i++){
				if(this.point[i].enable === true){
					ctx.fillRect(
						xc+(radius*this.point[i].x)-lr,
						yc+(radius*this.point[i].y)-lr,
						2*lr,
						2*lr);
				}
				else {
					ctx.rect(
						xc+(radius*this.point[i].x)-lr,
						yc+(radius*this.point[i].y)-lr,
						2*lr,
						2*lr);
				}
			}
			ctx.stroke();
			for(var i=0;i<this.point.length;i++){
				for(var jb=1;jb<this.point.length;jb++){
					j=(i+jb)%this.point.length;
					if(this.point[i].enable && this.point[j].enable){
						ctx.beginPath();
						if(this.isDuplicate(i,j,this.point.length)){
							ctx.strokeStyle = "#CCCCCC";
						}
						else {
							ctx.strokeStyle = "#000000";
						}
						ctx.moveTo(xc+(radius*this.point[i].x),
							yc+(radius*this.point[i].y));
						ctx.lineTo(xc+(radius*this.point[j].x),
							yc+(radius*this.point[j].y));
						ctx.stroke();
					}
				}
			}
		}
		this.point=[];
		this.init(total);
		this.decimate();

		var canvas = document.getElementById(id);
		var ctx = canvas.getContext("2d");

		this.draw(ctx);
	}
	var g=new PartialRing(5,"canvas5")
	g=new PartialRing(6,"canvas6")
	g=new PartialRing(7,"canvas7")
	g=new PartialRing(8,"canvas8")
	g=new PartialRing(9,"canvas9")
	g=new PartialRing(10,"canvasA")
	g=new PartialRing(11,"canvasB")
	g=new PartialRing(12,"canvasC")
</script>
</body>
</html>
